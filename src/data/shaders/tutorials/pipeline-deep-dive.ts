/**
 * GPUæ¸²æŸ“ç®¡çº¿æ·±åº¦è§£æ - ä»CPUåˆ°åƒç´ çš„å®Œæ•´æ—…ç¨‹
 * è¯¦ç»†å±•ç¤ºæ•°æ®å¦‚ä½•åœ¨æ¸²æŸ“ç®¡çº¿ä¸­æµåŠ¨å’Œå¤„ç†
 */
import type { ShaderExample } from '../../../types'

const pipelineDeepDive: ShaderExample = {
  id: 'pipeline-deep-dive',
  title: 'GPUæ¸²æŸ“ç®¡çº¿æ·±åº¦è§£æ',
  description: 'ä»åº•å±‚ç†è§£æ¸²æŸ“ç®¡çº¿ï¼šCPUåˆ°GPUçš„æ•°æ®ä¼ è¾“ã€é¡¶ç‚¹å¤„ç†ã€å›¾å…ƒè£…é…ã€å…‰æ …åŒ–ã€ç‰‡æ®µå¤„ç†çš„å®Œæ•´æµç¨‹ã€‚',
  level: 'intermediate',
  tags: ['ç®¡çº¿', 'åº•å±‚åŸç†', 'GPUæ¶æ„', 'æ•™å­¦'],

  vertexShader: /* glsl */ `
// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                    é¡¶ç‚¹ç€è‰²å™¨ - GPUç®¡çº¿ç¬¬ä¸€ä¸ªå¯ç¼–ç¨‹é˜¶æ®µ                      â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// ã€æ‰§è¡Œæ—¶æœºã€‘æ¯ä¸ªé¡¶ç‚¹ç‹¬ç«‹æ‰§è¡Œä¸€æ¬¡ï¼Œå®Œå…¨å¹¶è¡Œ
// ã€ç¡¬ä»¶ä½ç½®ã€‘åœ¨GPUçš„æµå¤„ç†å™¨(SM/CU)ä¸Šè¿è¡Œ
// ã€æ ¸å¿ƒèŒè´£ã€‘åæ ‡å˜æ¢ã€é¡¶ç‚¹å±æ€§è®¡ç®—

// ============================================
// è¾“å…¥ï¼šAttributeï¼ˆé¡¶ç‚¹å±æ€§ï¼‰
// ============================================
// attribute æ˜¯"é€é¡¶ç‚¹"æ•°æ®ï¼Œä» Vertex Buffer Object (VBO) è¯»å–
// æ¯æ¬¡è°ƒç”¨ï¼ŒGPUä¼šè‡ªåŠ¨ä¸ºå½“å‰é¡¶ç‚¹å¡«å……è¿™äº›å€¼
attribute vec2 a_position;  // é¡¶ç‚¹ä½ç½® - æ¥è‡ªCPUåˆ›å»ºçš„é¡¶ç‚¹æ•°ç»„

// ============================================
// è¾“å‡ºï¼šVaryingï¼ˆä¼ é€’ç»™ç‰‡æ®µç€è‰²å™¨ï¼‰
// ============================================
// varying å˜é‡ä¼šåœ¨å…‰æ …åŒ–é˜¶æ®µè¢«GPUè‡ªåŠ¨æ’å€¼
// è¿™æ˜¯é¡¶ç‚¹ç€è‰²å™¨ä¸ç‰‡æ®µç€è‰²å™¨çš„"æ¡¥æ¢"
varying vec2 v_uv;              // UVåæ ‡
varying vec2 v_ndcPosition;     // ä¿å­˜NDCåæ ‡ç”¨äºå¯è§†åŒ–
varying float v_vertexID;       // æ¨¡æ‹Ÿé¡¶ç‚¹IDï¼ˆç”¨äºæ•™å­¦æ¼”ç¤ºï¼‰

void main() {
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // é˜¶æ®µ1: è¾“å…¥æ•°æ®æ¥æ”¶
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // æ­¤æ—¶ a_position å·²ç»ç”±GPUä»VBOä¸­è¯»å–
    // å¯¹äºä¸€ä¸ªå…¨å±å››è¾¹å½¢ï¼Œæˆ‘ä»¬æœ‰4ä¸ªé¡¶ç‚¹ï¼ˆæˆ–6ä¸ªï¼Œå¦‚æœæ˜¯ä¸¤ä¸ªä¸‰è§’å½¢ï¼‰
    // æ¯ä¸ªé¡¶ç‚¹ä¼šç‹¬ç«‹ã€å¹¶è¡Œåœ°æ‰§è¡Œè¿™ä¸ªmain()å‡½æ•°
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // é˜¶æ®µ2: åæ ‡ç©ºé—´å˜æ¢
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // å®Œæ•´çš„3Då˜æ¢é“¾ï¼š
    // æ¨¡å‹ç©ºé—´ â†’ ä¸–ç•Œç©ºé—´ â†’ è§†å›¾ç©ºé—´ â†’ è£å‰ªç©ºé—´ â†’ NDC
    //
    // æœ¬ç¤ºä¾‹æ˜¯2Dï¼Œç®€åŒ–ä¸ºç›´æ¥è®¾ç½®è£å‰ªç©ºé—´åæ ‡
    // gl_Position æ˜¯ä¸€ä¸ª vec4ï¼Œæ ¼å¼ä¸º (x, y, z, w)
    // GPUä¼šè‡ªåŠ¨æ‰§è¡Œé€è§†é™¤æ³•: NDC = (x/w, y/w, z/w)
    
    gl_Position = vec4(a_position, 0.0, 1.0);
    
    // ä¿å­˜NDCåæ ‡ä¾›ç‰‡æ®µç€è‰²å™¨ä½¿ç”¨
    v_ndcPosition = a_position;
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // é˜¶æ®µ3: è®¡ç®—è¦ä¼ é€’çš„æ•°æ®
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ä»NDC [-1,1] æ˜ å°„åˆ° UV [0,1]
    v_uv = a_position * 0.5 + 0.5;
    
    // æ¨¡æ‹Ÿé¡¶ç‚¹IDï¼ˆå®é™…WebGL2æœ‰gl_VertexIDï¼‰
    // æ ¹æ®ä½ç½®æ¨ç®—æ˜¯å“ªä¸ªé¡¶ç‚¹
    v_vertexID = (a_position.x + 1.0) * 0.5 + (a_position.y + 1.0);
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ã€é‡è¦ã€‘é¡¶ç‚¹ç€è‰²å™¨ç»“æŸåä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 1. GPUæ”¶é›†æ‰€æœ‰é¡¶ç‚¹çš„è¾“å‡º
    // 2. æ ¹æ®ç»˜åˆ¶æ¨¡å¼(TRIANGLESç­‰)ç»„è£…å›¾å…ƒ
    // 3. è¿›è¡Œè£å‰ªæµ‹è¯•ï¼ˆè¶…å‡º[-1,1]çš„éƒ¨åˆ†ï¼‰
    // 4. æ‰§è¡Œé€è§†é™¤æ³•ï¼ˆå¦‚æœwâ‰ 1ï¼‰
    // 5. è§†å£å˜æ¢ï¼ˆNDCâ†’å±å¹•åƒç´ åæ ‡ï¼‰
    // 6. å¼€å§‹å…‰æ …åŒ–...
}`,

  fragmentShader: /* glsl */ `
// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                    ç‰‡æ®µç€è‰²å™¨ - GPUç®¡çº¿æœ€åä¸€ä¸ªå¯ç¼–ç¨‹é˜¶æ®µ                    â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// ã€æ‰§è¡Œæ—¶æœºã€‘æ¯ä¸ªç‰‡æ®µï¼ˆæ½œåœ¨åƒç´ ï¼‰ç‹¬ç«‹æ‰§è¡Œï¼Œå¤§è§„æ¨¡å¹¶è¡Œ
// ã€æ‰§è¡Œæ•°é‡ã€‘å¯èƒ½æ•°ç™¾ä¸‡æ¬¡ï¼ï¼ˆå–å†³äºå›¾å…ƒè¦†ç›–çš„åƒç´ æ•°ï¼‰
// ã€æ ¸å¿ƒèŒè´£ã€‘è®¡ç®—æœ€ç»ˆåƒç´ é¢œè‰²

precision highp float;

// ============================================
// è¾“å…¥ï¼šVaryingï¼ˆå·²æ’å€¼ï¼‰
// ============================================
// è¿™äº›å€¼å·²ç»è¢«å…‰æ …åŒ–å™¨æ ¹æ®é‡å¿ƒåæ ‡æ’å€¼ï¼
varying vec2 v_uv;
varying vec2 v_ndcPosition;
varying float v_vertexID;

// ============================================
// è¾“å…¥ï¼šUniformï¼ˆå…¨å±€å¸¸é‡ï¼‰
// ============================================
// uniform åœ¨æ•´ä¸ªç»˜åˆ¶è°ƒç”¨æœŸé—´ä¿æŒä¸å˜
// æ‰€æœ‰é¡¶ç‚¹å’Œç‰‡æ®µçœ‹åˆ°çš„æ˜¯åŒä¸€ä¸ªå€¼
uniform float u_time;
uniform vec2 u_resolution;
uniform vec2 u_mouse;

// ============================================
// è¾…åŠ©å‡½æ•°
// ============================================

// ç»˜åˆ¶ç‚¹
float drawPoint(vec2 p, vec2 center, float radius) {
    return 1.0 - smoothstep(radius - 0.01, radius + 0.01, length(p - center));
}

// ç»˜åˆ¶çº¿æ®µ
float drawLine(vec2 p, vec2 a, vec2 b, float width) {
    vec2 pa = p - a, ba = b - a;
    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
    return 1.0 - smoothstep(width - 0.005, width + 0.005, length(pa - ba * h));
}

// ç»˜åˆ¶ç®­å¤´
float drawArrow(vec2 p, vec2 start, vec2 end, float width) {
    float line = drawLine(p, start, end, width);
    vec2 dir = normalize(end - start);
    vec2 perp = vec2(-dir.y, dir.x);
    vec2 tip1 = end - dir * 0.05 + perp * 0.03;
    vec2 tip2 = end - dir * 0.05 - perp * 0.03;
    line = max(line, drawLine(p, end, tip1, width));
    line = max(line, drawLine(p, end, tip2, width));
    return line;
}

// ç»˜åˆ¶ç½‘æ ¼
float drawGrid(vec2 p, float spacing, float thickness) {
    vec2 grid = abs(fract(p / spacing - 0.5) - 0.5) * spacing;
    return 1.0 - smoothstep(thickness, thickness + 0.005, min(grid.x, grid.y));
}

// ç»˜åˆ¶çŸ©å½¢è¾¹æ¡†
float drawRect(vec2 p, vec2 center, vec2 size, float thickness) {
    vec2 d = abs(p - center) - size;
    float outside = length(max(d, 0.0));
    float inside = min(max(d.x, d.y), 0.0);
    float dist = outside + inside;
    return 1.0 - smoothstep(0.0, thickness, abs(dist));
}

// æ•°å­—æ˜¾ç¤ºï¼ˆç®€åŒ–ç‰ˆ - æ˜¾ç¤º0-9ï¼‰
float digit(vec2 p, int n) {
    // ç®€åŒ–ï¼šç”¨ç‚¹é˜µæ¨¡æ‹Ÿæ•°å­—
    p = p * 10.0;
    if (p.x < 0.0 || p.x > 3.0 || p.y < 0.0 || p.y > 5.0) return 0.0;
    
    // éå¸¸ç®€åŒ–çš„æ•°å­—è¡¨ç¤º
    float d = 0.0;
    if (n == 0) {
        d = drawRect(p, vec2(1.5, 2.5), vec2(1.0, 2.0), 0.3);
    } else if (n == 1) {
        d = drawLine(p, vec2(1.5, 0.0), vec2(1.5, 5.0), 0.2);
    } else if (n == 2) {
        // ç®€åŒ–çš„2
        d = max(drawLine(p, vec2(0.5, 4.5), vec2(2.5, 4.5), 0.2),
                drawLine(p, vec2(0.5, 0.5), vec2(2.5, 0.5), 0.2));
    }
    return d;
}

void main() {
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ã€åº•å±‚åŸç†ã€‘æ­¤æ—¶GPUå·²å®Œæˆçš„å·¥ä½œï¼š
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 1. é¡¶ç‚¹ç€è‰²å™¨å·²å¤„ç†æ‰€æœ‰é¡¶ç‚¹
    // 2. å›¾å…ƒå·²è£…é…ï¼ˆ3ä¸ªé¡¶ç‚¹â†’1ä¸ªä¸‰è§’å½¢ï¼‰
    // 3. å…‰æ …åŒ–å™¨å·²ç¡®å®šè¿™ä¸ªåƒç´ è¢«ä¸‰è§’å½¢è¦†ç›–
    // 4. v_uv ç­‰ varying å˜é‡å·²æ ¹æ®é‡å¿ƒåæ ‡æ’å€¼
    // 5. ç°åœ¨è½®åˆ°æˆ‘ä»¬è®¡ç®—è¿™ä¸ªåƒç´ çš„é¢œè‰²äº†ï¼
    
    vec2 uv = v_uv;
    vec2 aspect = vec2(u_resolution.x / u_resolution.y, 1.0);
    
    // æ ¡æ­£å®½é«˜æ¯”çš„åæ ‡
    vec2 p = (uv - 0.5) * aspect;
    
    vec3 color = vec3(0.02, 0.03, 0.05);
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // å¯è§†åŒ–1: æ¸²æŸ“ç®¡çº¿æ•°æ®æµ
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // æ˜¾ç¤ºç®¡çº¿é˜¶æ®µï¼ˆä¸ŠåŠéƒ¨åˆ†ï¼‰
    if (uv.y > 0.55) {
        vec2 pipeUV = vec2((uv.x - 0.0) / 1.0, (uv.y - 0.55) / 0.45);
        
        // èƒŒæ™¯
        color = vec3(0.05, 0.06, 0.1);
        
        // ç®¡çº¿é˜¶æ®µæ–¹å—
        float stageWidth = 0.13;
        float stageHeight = 0.4;
        float startX = 0.08;
        float spacing = 0.155;
        float stageY = 0.5;
        
        // å®šä¹‰6ä¸ªé˜¶æ®µ
        vec3 stageColors[6];
        stageColors[0] = vec3(0.2, 0.5, 0.9);  // CPU/é¡¶ç‚¹æ•°æ®
        stageColors[1] = vec3(0.9, 0.4, 0.3);  // é¡¶ç‚¹ç€è‰²å™¨
        stageColors[2] = vec3(0.9, 0.7, 0.2);  // å›¾å…ƒè£…é…
        stageColors[3] = vec3(0.3, 0.8, 0.5);  // å…‰æ …åŒ–
        stageColors[4] = vec3(0.8, 0.3, 0.7);  // ç‰‡æ®µç€è‰²å™¨
        stageColors[5] = vec3(0.3, 0.6, 0.9);  // å¸§ç¼“å†²
        
        // ç»˜åˆ¶é˜¶æ®µ
        for (int i = 0; i < 6; i++) {
            float x = startX + float(i) * spacing;
            vec2 center = vec2(x, stageY);
            
            // æ–¹å—
            float boxDist = max(abs(pipeUV.x - center.x) - stageWidth * 0.5,
                               abs(pipeUV.y - center.y) - stageHeight * 0.5);
            
            // å¡«å……
            float fill = 1.0 - smoothstep(-0.005, 0.005, boxDist);
            // åŠ¨ç”»é«˜äº® - æ•°æ®æµè¿‡æ•ˆæœ
            float flowPhase = fract(u_time * 0.3 - float(i) * 0.15);
            float highlight = smoothstep(0.0, 0.3, flowPhase) * smoothstep(0.6, 0.3, flowPhase);
            vec3 stageColor = stageColors[i] * (0.6 + highlight * 0.4);
            color = mix(color, stageColor, fill);
            
            // è¾¹æ¡†
            float border = 1.0 - smoothstep(0.0, 0.015, abs(boxDist));
            color = mix(color, vec3(1.0), border * 0.8);
            
            // è¿æ¥ç®­å¤´
            if (i < 5) {
                float arrowX = x + stageWidth * 0.5 + spacing * 0.15;
                float arrowLen = spacing * 0.4;
                float arrow = drawArrow(pipeUV, 
                    vec2(arrowX, stageY), 
                    vec2(arrowX + arrowLen, stageY), 
                    0.008);
                
                // ç®­å¤´åŠ¨ç”»
                float arrowFlow = fract(u_time * 0.5 - float(i) * 0.15);
                vec3 arrowColor = mix(vec3(0.3), vec3(0.0, 1.0, 0.8), arrowFlow);
                color = mix(color, arrowColor, arrow);
            }
        }
        
        // æ•°æ®æµç²’å­
        for (int i = 0; i < 6; i++) {
            float particlePhase = fract(u_time * 0.4 + float(i) * 0.166);
            float particleX = startX + particlePhase * (5.0 * spacing + stageWidth);
            float particleY = stageY;
            
            float particle = drawPoint(pipeUV, vec2(particleX, particleY), 0.015);
            color = mix(color, vec3(1.0, 0.9, 0.5), particle * 0.8);
        }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // å¯è§†åŒ–2: é‡å¿ƒåæ ‡æ’å€¼æ¼”ç¤ºï¼ˆå·¦ä¸‹ï¼‰
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    else if (uv.x < 0.5) {
        vec2 localUV = vec2(uv.x / 0.5, uv.y / 0.55);
        vec2 lp = (localUV - 0.5) * 2.0 * vec2(1.0, 0.9);
        
        // èƒŒæ™¯ç½‘æ ¼
        float grid = drawGrid(lp, 0.2, 0.005) * 0.15;
        color = vec3(0.03, 0.04, 0.08) + grid;
        
        // ä¸‰è§’å½¢é¡¶ç‚¹
        vec2 v0 = vec2(-0.6, -0.5);
        vec2 v1 = vec2(0.6, -0.5);
        vec2 v2 = vec2(0.0, 0.6);
        
        // ä¸‰è§’å½¢è¾¹
        float tri = 0.0;
        tri = max(tri, drawLine(lp, v0, v1, 0.01));
        tri = max(tri, drawLine(lp, v1, v2, 0.01));
        tri = max(tri, drawLine(lp, v2, v0, 0.01));
        color = mix(color, vec3(0.5, 0.5, 0.6), tri);
        
        // è®¡ç®—é‡å¿ƒåæ ‡ï¼ˆç”¨äºç€è‰²ï¼‰
        vec2 v0v1 = v1 - v0;
        vec2 v0v2 = v2 - v0;
        vec2 v0p = lp - v0;
        float d00 = dot(v0v1, v0v1);
        float d01 = dot(v0v1, v0v2);
        float d11 = dot(v0v2, v0v2);
        float d20 = dot(v0p, v0v1);
        float d21 = dot(v0p, v0v2);
        float denom = d00 * d11 - d01 * d01;
        float baryV = (d11 * d20 - d01 * d21) / denom;
        float baryW = (d00 * d21 - d01 * d20) / denom;
        float baryU = 1.0 - baryV - baryW;
        
        // æ£€æŸ¥æ˜¯å¦åœ¨ä¸‰è§’å½¢å†…
        bool inside = baryU >= 0.0 && baryV >= 0.0 && baryW >= 0.0;
        
        if (inside) {
            // é¡¶ç‚¹é¢œè‰²
            vec3 c0 = vec3(1.0, 0.2, 0.2);  // çº¢
            vec3 c1 = vec3(0.2, 1.0, 0.2);  // ç»¿
            vec3 c2 = vec3(0.2, 0.2, 1.0);  // è“
            
            // é‡å¿ƒåæ ‡æ’å€¼ï¼
            vec3 interpColor = c0 * baryU + c1 * baryV + c2 * baryW;
            color = interpColor;
            
            // æ˜¾ç¤ºç­‰å€¼çº¿
            float isoU = 1.0 - smoothstep(0.0, 0.02, abs(fract(baryU * 10.0) - 0.5) - 0.4);
            float isoV = 1.0 - smoothstep(0.0, 0.02, abs(fract(baryV * 10.0) - 0.5) - 0.4);
            float isoW = 1.0 - smoothstep(0.0, 0.02, abs(fract(baryW * 10.0) - 0.5) - 0.4);
            color = mix(color, vec3(1.0), (isoU + isoV + isoW) * 0.2);
        }
        
        // é¡¶ç‚¹æ ‡è®°
        color = mix(color, vec3(1.0, 0.3, 0.3), drawPoint(lp, v0, 0.05));
        color = mix(color, vec3(0.3, 1.0, 0.3), drawPoint(lp, v1, 0.05));
        color = mix(color, vec3(0.3, 0.3, 1.0), drawPoint(lp, v2, 0.05));
        
        // é¼ æ ‡ä½ç½®æŒ‡ç¤ºå™¨ï¼ˆå¦‚æœé¼ æ ‡åœ¨æ­¤åŒºåŸŸï¼‰
        vec2 mouseLocal = (u_mouse / u_resolution - vec2(0.0, 0.45)) * vec2(2.0, 1.0 / 0.55);
        if (mouseLocal.x > 0.0 && mouseLocal.x < 1.0 && mouseLocal.y > 0.0 && mouseLocal.y < 1.0) {
            vec2 mouseP = (mouseLocal - 0.5) * 2.0 * vec2(1.0, 0.9);
            color = mix(color, vec3(1.0, 1.0, 0.0), drawPoint(lp, mouseP, 0.03));
        }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // å¯è§†åŒ–3: åƒç´ /ç‰‡æ®µå¤„ç†æ¼”ç¤ºï¼ˆå³ä¸‹ï¼‰
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    else {
        vec2 localUV = vec2((uv.x - 0.5) / 0.5, uv.y / 0.55);
        vec2 lp = localUV;
        
        // åƒç´ ç½‘æ ¼èƒŒæ™¯
        color = vec3(0.04, 0.05, 0.09);
        
        // ç½‘æ ¼å¤§å°
        float gridSize = 12.0;
        vec2 gridUV = localUV * gridSize;
        vec2 gridCell = floor(gridUV);
        vec2 cellUV = fract(gridUV);
        
        // ç»˜åˆ¶åƒç´ æ ¼å­
        float cellBorder = 1.0 - smoothstep(0.0, 0.08, min(
            min(cellUV.x, 1.0 - cellUV.x),
            min(cellUV.y, 1.0 - cellUV.y)
        ));
        color += vec3(0.1) * cellBorder;
        
        // æ¨¡æ‹Ÿä¸€ä¸ªä¸‰è§’å½¢è¦†ç›–æµ‹è¯•
        vec2 triV0 = vec2(2.0, 2.0);
        vec2 triV1 = vec2(10.0, 3.0);
        vec2 triV2 = vec2(6.0, 10.0);
        
        // è®¡ç®—å½“å‰æ ¼å­ä¸­å¿ƒæ˜¯å¦åœ¨ä¸‰è§’å½¢å†…
        vec2 cellCenter = gridCell + 0.5;
        
        // ä½¿ç”¨è¾¹å‡½æ•°æµ‹è¯•
        float edge0 = (cellCenter.x - triV0.x) * (triV1.y - triV0.y) - (cellCenter.y - triV0.y) * (triV1.x - triV0.x);
        float edge1 = (cellCenter.x - triV1.x) * (triV2.y - triV1.y) - (cellCenter.y - triV1.y) * (triV2.x - triV1.x);
        float edge2 = (cellCenter.x - triV2.x) * (triV0.y - triV2.y) - (cellCenter.y - triV2.y) * (triV0.x - triV2.x);
        
        bool inTriangle = edge0 >= 0.0 && edge1 >= 0.0 && edge2 >= 0.0;
        
        if (inTriangle) {
            // è¢«ä¸‰è§’å½¢è¦†ç›–çš„åƒç´ 
            float wave = sin(u_time * 3.0 + gridCell.x * 0.5 + gridCell.y * 0.7) * 0.5 + 0.5;
            vec3 fillColor = vec3(0.2 + wave * 0.3, 0.5, 0.8);
            
            // å¡«å……åŠ¨ç”»æ•ˆæœ
            float fillDelay = (gridCell.x + gridCell.y) * 0.1;
            float fillProgress = fract(u_time * 0.3 - fillDelay);
            float fillAmount = smoothstep(0.0, 0.3, fillProgress);
            
            color = mix(color, fillColor, fillAmount * 0.8);
            
            // é«˜äº®å½“å‰æ­£åœ¨å¤„ç†çš„åƒç´ 
            float processPhase = fract(u_time * 2.0);
            float processX = floor(processPhase * gridSize);
            float processY = floor(fract(u_time * 0.5) * gridSize);
            
            if (abs(gridCell.x - processX) < 0.5 && abs(gridCell.y - processY) < 0.5) {
                color = mix(color, vec3(1.0, 1.0, 0.0), 0.5);
            }
        }
        
        // ç»˜åˆ¶ä¸‰è§’å½¢è½®å»“ï¼ˆåœ¨åƒç´ ç½‘æ ¼ä¸Šï¼‰
        vec2 t0 = triV0 / gridSize;
        vec2 t1 = triV1 / gridSize;
        vec2 t2 = triV2 / gridSize;
        
        float triLine = 0.0;
        triLine = max(triLine, drawLine(lp, t0, t1, 0.015));
        triLine = max(triLine, drawLine(lp, t1, t2, 0.015));
        triLine = max(triLine, drawLine(lp, t2, t0, 0.015));
        color = mix(color, vec3(1.0, 0.5, 0.2), triLine);
        
        // é¡¶ç‚¹æ ‡è®°
        color = mix(color, vec3(1.0, 0.3, 0.3), drawPoint(lp, t0, 0.03));
        color = mix(color, vec3(0.3, 1.0, 0.3), drawPoint(lp, t1, 0.03));
        color = mix(color, vec3(0.3, 0.3, 1.0), drawPoint(lp, t2, 0.03));
    }
    
    // åˆ†å‰²çº¿
    float dividerH = smoothstep(0.008, 0.0, abs(uv.y - 0.55));
    float dividerV = smoothstep(0.005, 0.0, abs(uv.x - 0.5)) * step(uv.y, 0.55);
    color = mix(color, vec3(0.4, 0.5, 0.6), max(dividerH, dividerV));
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ã€è¾“å‡ºã€‘gl_FragColor æ˜¯ç‰‡æ®µç€è‰²å™¨çš„å”¯ä¸€è¾“å‡º
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ä¹‹åGPUè¿˜ä¼šè¿›è¡Œï¼š
    // 1. Alphaæµ‹è¯•ï¼ˆå¦‚æœå¯ç”¨ï¼‰
    // 2. æ¨¡æ¿æµ‹è¯•ï¼ˆå¦‚æœå¯ç”¨ï¼‰
    // 3. æ·±åº¦æµ‹è¯•ï¼ˆå¦‚æœå¯ç”¨ï¼‰
    // 4. æ··åˆï¼ˆå¦‚æœå¯ç”¨Alphaæ··åˆï¼‰
    // 5. å†™å…¥å¸§ç¼“å†²
    
    gl_FragColor = vec4(color, 1.0);
}`,

  explanation: `
## GPUæ¸²æŸ“ç®¡çº¿æ·±åº¦è§£æ - ä»CPUåˆ°åƒç´ çš„å®Œæ•´æ—…ç¨‹

### ğŸ¯ æ¦‚è¿°

ç°ä»£GPUæ¸²æŸ“ç®¡çº¿æ˜¯ä¸€ä¸ªå¤æ‚ä½†ä¼˜é›…çš„æµæ°´çº¿ç³»ç»Ÿã€‚ç†è§£å®ƒçš„å·¥ä½œåŸç†æ˜¯æŒæ¡Shaderç¼–ç¨‹çš„å…³é”®ã€‚

---

## ç¬¬ä¸€é˜¶æ®µï¼šCPUç«¯å‡†å¤‡

### 1.1 é¡¶ç‚¹æ•°æ®å‡†å¤‡

åœ¨GPUå¼€å§‹å·¥ä½œä¹‹å‰ï¼ŒCPUéœ€è¦å‡†å¤‡å¥½æ‰€æœ‰æ•°æ®ï¼š

\`\`\`javascript
// CPUç«¯ä»£ç ç¤ºä¾‹
const vertices = new Float32Array([
    -1.0, -1.0,  // é¡¶ç‚¹0: å·¦ä¸‹
     1.0, -1.0,  // é¡¶ç‚¹1: å³ä¸‹
    -1.0,  1.0,  // é¡¶ç‚¹2: å·¦ä¸Š
     1.0,  1.0   // é¡¶ç‚¹3: å³ä¸Š
]);

// åˆ›å»ºå¹¶ä¸Šä¼ åˆ°GPU
const vbo = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
\`\`\`

### 1.2 æ•°æ®ä¼ è¾“æœºåˆ¶

| å­˜å‚¨ä½ç½® | è®¿é—®é€Ÿåº¦ | å®¹é‡ | ç”¨é€” |
|---------|---------|-----|------|
| CPUå†…å­˜ | è¾ƒæ…¢ | GBçº§ | å­˜å‚¨åŸå§‹èµ„æº |
| PCIeæ€»çº¿ | ç“¶é¢ˆ | - | CPUâ†”GPUä¼ è¾“ |
| GPUæ˜¾å­˜ | æå¿« | GBçº§ | GPUç›´æ¥è®¿é—® |
| GPUç¼“å­˜ | æœ€å¿« | MBçº§ | çƒ­ç‚¹æ•°æ® |

---

## ç¬¬äºŒé˜¶æ®µï¼šé¡¶ç‚¹ç€è‰²å™¨

### 2.1 æ‰§è¡Œæ¨¡å‹

\`\`\`
é¡¶ç‚¹0 â”€â†’ [é¡¶ç‚¹ç€è‰²å™¨å®ä¾‹0] â”€â†’ è¾“å‡º0
é¡¶ç‚¹1 â”€â†’ [é¡¶ç‚¹ç€è‰²å™¨å®ä¾‹1] â”€â†’ è¾“å‡º1   â† å®Œå…¨å¹¶è¡Œï¼
é¡¶ç‚¹2 â”€â†’ [é¡¶ç‚¹ç€è‰²å™¨å®ä¾‹2] â”€â†’ è¾“å‡º2
...
\`\`\`

**å…³é”®æ¦‚å¿µ**ï¼šæ¯ä¸ªé¡¶ç‚¹ç‹¬ç«‹å¤„ç†ï¼Œäº’ä¸å¹²æ‰°ã€‚GPUå¯ä»¥åŒæ—¶å¤„ç†æ•°åƒä¸ªé¡¶ç‚¹ã€‚

### 2.2 è¾“å…¥è¾“å‡º

\`\`\`glsl
// è¾“å…¥ - ä»VBOè¯»å–
attribute vec3 a_position;  // æ¯é¡¶ç‚¹ä¸åŒ
attribute vec2 a_texCoord;  // æ¯é¡¶ç‚¹ä¸åŒ

// è¾“å‡º - ä¼ é€’ç»™ä¸‹ä¸€é˜¶æ®µ
varying vec2 v_texCoord;    // å°†è¢«æ’å€¼

// å¿…é¡»è¾“å‡º
gl_Position = ...;  // è£å‰ªç©ºé—´åæ ‡
\`\`\`

### 2.3 åæ ‡å˜æ¢é“¾

\`\`\`
æ¨¡å‹ç©ºé—´ â”€â”€[ModelçŸ©é˜µ]â”€â”€â†’ ä¸–ç•Œç©ºé—´
    â”‚
    â””â”€â”€[ViewçŸ©é˜µ]â”€â”€â†’ è§†å›¾ç©ºé—´
            â”‚
            â””â”€â”€[ProjectionçŸ©é˜µ]â”€â”€â†’ è£å‰ªç©ºé—´
                    â”‚
                    â””â”€â”€[é€è§†é™¤æ³•]â”€â”€â†’ NDC
                            â”‚
                            â””â”€â”€[è§†å£å˜æ¢]â”€â”€â†’ å±å¹•ç©ºé—´
\`\`\`

---

## ç¬¬ä¸‰é˜¶æ®µï¼šå›¾å…ƒè£…é…

### 3.1 è£…é…æ¨¡å¼

\`\`\`
gl.TRIANGLES:    æ¯3ä¸ªé¡¶ç‚¹ â†’ 1ä¸ªä¸‰è§’å½¢
gl.TRIANGLE_STRIP: é¡¶ç‚¹å…±äº«ï¼Œæ›´é«˜æ•ˆ
gl.TRIANGLE_FAN:   æ‰‡å½¢ä¸‰è§’å½¢
gl.LINES:         æ¯2ä¸ªé¡¶ç‚¹ â†’ 1æ¡çº¿
gl.POINTS:        æ¯ä¸ªé¡¶ç‚¹ â†’ 1ä¸ªç‚¹
\`\`\`

### 3.2 è£å‰ª

è¶…å‡ºNDCèŒƒå›´[-1,1]çš„å›¾å…ƒä¼šè¢«è£å‰ªï¼š
- å®Œå…¨åœ¨å¤–ï¼šä¸¢å¼ƒ
- éƒ¨åˆ†åœ¨å¤–ï¼šåˆ‡å‰²æˆå¤šä¸ªå›¾å…ƒ

---

## ç¬¬å››é˜¶æ®µï¼šå…‰æ …åŒ– â­

### 4.1 æ ¸å¿ƒä»»åŠ¡

**ç¡®å®šå“ªäº›åƒç´ è¢«ä¸‰è§’å½¢è¦†ç›–**

è¿™æ˜¯ç¡¬ä»¶å®ç°çš„ï¼Œéå¸¸é«˜æ•ˆï¼

### 4.2 åƒç´ è¦†ç›–æµ‹è¯•

\`\`\`
å¯¹äºå±å¹•ä¸Šçš„æ¯ä¸ªåƒç´ ï¼š
    è®¡ç®—åƒç´ ä¸­å¿ƒç‚¹
    æµ‹è¯•è¯¥ç‚¹æ˜¯å¦åœ¨ä¸‰è§’å½¢å†…éƒ¨
    å¦‚æœåœ¨å†…éƒ¨ â†’ ç”Ÿæˆä¸€ä¸ªç‰‡æ®µ
\`\`\`

### 4.3 é‡å¿ƒåæ ‡æ’å€¼ â­â­â­

**è¿™æ˜¯Shaderç¼–ç¨‹ä¸­æœ€é‡è¦çš„æ¦‚å¿µä¹‹ä¸€ï¼**

å‡è®¾ä¸‰è§’å½¢ä¸‰ä¸ªé¡¶ç‚¹åˆ†åˆ«æœ‰é¢œè‰² C0, C1, C2ï¼ŒæŸåƒç´ çš„é¢œè‰²å¦‚ä½•ç¡®å®šï¼Ÿ

\`\`\`
Pç‚¹çš„é¢œè‰² = C0 Ã— Î»0 + C1 Ã— Î»1 + C2 Ã— Î»2

å…¶ä¸­ Î»0 + Î»1 + Î»2 = 1ï¼ˆé‡å¿ƒåæ ‡ï¼‰
\`\`\`

**æ•°å­¦åŸç†**ï¼š
\`\`\`glsl
// è®¡ç®—é‡å¿ƒåæ ‡
vec3 barycentric(vec2 p, vec2 a, vec2 b, vec2 c) {
    vec2 v0 = c - a, v1 = b - a, v2 = p - a;
    float d00 = dot(v0, v0);
    float d01 = dot(v0, v1);
    float d11 = dot(v1, v1);
    float d20 = dot(v2, v0);
    float d21 = dot(v2, v1);
    float denom = d00 * d11 - d01 * d01;
    
    float v = (d11 * d20 - d01 * d21) / denom;
    float w = (d00 * d21 - d01 * d20) / denom;
    float u = 1.0 - v - w;
    
    return vec3(u, v, w);
}
\`\`\`

---

## ç¬¬äº”é˜¶æ®µï¼šç‰‡æ®µç€è‰²å™¨

### 5.1 æ‰§è¡Œè§„æ¨¡

\`\`\`
å±å¹•åˆ†è¾¨ç‡: 1920 Ã— 1080
æ€»åƒç´ æ•°: 2,073,600
æ¯å¸§æ‰§è¡Œæ¬¡æ•°: æœ€å¤š 2,073,600 æ¬¡ï¼
\`\`\`

### 5.2 å¹¶è¡Œæ‰§è¡Œ

\`\`\`
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  GPU åŒæ—¶å¤„ç†æ•°åƒä¸ªç‰‡æ®µ              â”‚
â”‚                                      â”‚
â”‚  ç‰‡æ®µ(0,0) â†’ [FS] â†’ é¢œè‰²            â”‚
â”‚  ç‰‡æ®µ(0,1) â†’ [FS] â†’ é¢œè‰²   â† å¹¶è¡Œ!  â”‚
â”‚  ç‰‡æ®µ(1,0) â†’ [FS] â†’ é¢œè‰²            â”‚
â”‚  ...                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
\`\`\`

### 5.3 å†…ç½®å˜é‡

\`\`\`glsl
// è¾“å…¥
gl_FragCoord.xy  // åƒç´ åæ ‡ï¼ˆå·¦ä¸‹è§’åŸç‚¹ï¼‰
gl_FragCoord.z   // æ·±åº¦å€¼ [0,1]
gl_FrontFacing   // æ˜¯å¦æ˜¯æ­£é¢

// è¾“å‡º
gl_FragColor     // æœ€ç»ˆé¢œè‰²ï¼ˆWebGL 1.0ï¼‰
\`\`\`

---

## ç¬¬å…­é˜¶æ®µï¼šå¸§ç¼“å†²æ“ä½œ

### 6.1 æµ‹è¯•æµç¨‹

\`\`\`
ç‰‡æ®µé¢œè‰²
    â”‚
    â”œâ”€â†’ Scissoræµ‹è¯•ï¼ˆè£å‰ªçŸ©å½¢ï¼‰
    â”‚
    â”œâ”€â†’ Alphaæµ‹è¯•ï¼ˆé€æ˜åº¦é˜ˆå€¼ï¼‰
    â”‚
    â”œâ”€â†’ Stencilæµ‹è¯•ï¼ˆæ¨¡æ¿ï¼‰
    â”‚
    â”œâ”€â†’ Depthæµ‹è¯•ï¼ˆæ·±åº¦ï¼‰
    â”‚
    â””â”€â†’ é¢œè‰²æ··åˆ â†’ å¸§ç¼“å†²
\`\`\`

### 6.2 æ·±åº¦æµ‹è¯•

\`\`\`glsl
// å¯ç”¨æ·±åº¦æµ‹è¯•
gl.enable(gl.DEPTH_TEST);
gl.depthFunc(gl.LESS);  // åªæœ‰æ›´è¿‘çš„åƒç´ æ‰èƒ½é€šè¿‡
\`\`\`

### 6.3 æ··åˆæ–¹ç¨‹

\`\`\`
æœ€ç»ˆé¢œè‰² = æºé¢œè‰² Ã— æºå› å­ + ç›®æ ‡é¢œè‰² Ã— ç›®æ ‡å› å­

// å¸¸è§çš„Alphaæ··åˆ
gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
\`\`\`

---

## ğŸ“Š æ€§èƒ½è€ƒè™‘

### å…³é”®ç“¶é¢ˆ

| é˜¶æ®µ | ç“¶é¢ˆç±»å‹ | ä¼˜åŒ–æ–¹å‘ |
|-----|---------|---------|
| CPUâ†’GPU | å¸¦å®½ | å‡å°‘æ•°æ®ä¼ è¾“ |
| é¡¶ç‚¹ç€è‰²å™¨ | è®¡ç®— | ç®€åŒ–å˜æ¢ |
| å…‰æ …åŒ– | å¡«å……ç‡ | å‡å°‘overdraw |
| ç‰‡æ®µç€è‰²å™¨ | è®¡ç®—/å¸¦å®½ | ç®€åŒ–è®¡ç®—ï¼Œå‡å°‘çº¹ç†é‡‡æ · |

### é»„é‡‘æ³•åˆ™

\`\`\`
1. å°½é‡åœ¨é¡¶ç‚¹ç€è‰²å™¨ä¸­è®¡ç®— â†’ æ‰§è¡Œæ¬¡æ•°å°‘
2. é¿å…åœ¨ç‰‡æ®µç€è‰²å™¨ä¸­ä½¿ç”¨åˆ†æ”¯ â†’ å½±å“å¹¶è¡Œ
3. å‡å°‘çº¹ç†é‡‡æ ·æ¬¡æ•° â†’ å¸¦å®½ç“¶é¢ˆ
4. åˆ©ç”¨æ—©æœŸæ·±åº¦æµ‹è¯• â†’ è·³è¿‡ä¸å¯è§ç‰‡æ®µ
\`\`\`

---

## ğŸ¨ æ¼”ç¤ºåŒºåŸŸè¯´æ˜

| åŒºåŸŸ | æ¼”ç¤ºå†…å®¹ |
|-----|---------|
| ä¸Šæ–¹ | å®Œæ•´æ¸²æŸ“ç®¡çº¿æµç¨‹å›¾ï¼Œæ•°æ®æµåŠ¨åŠ¨ç”» |
| å·¦ä¸‹ | é‡å¿ƒåæ ‡æ’å€¼åŸç†ï¼Œvaryingå¦‚ä½•è¢«æ’å€¼ |
| å³ä¸‹ | å…‰æ …åŒ–åƒç´ å¡«å……è¿‡ç¨‹ï¼Œä¸‰è§’å½¢è¦†ç›–æµ‹è¯• |
`,

  uniforms: ['u_time', 'u_resolution', 'u_mouse']
}

export default pipelineDeepDive
